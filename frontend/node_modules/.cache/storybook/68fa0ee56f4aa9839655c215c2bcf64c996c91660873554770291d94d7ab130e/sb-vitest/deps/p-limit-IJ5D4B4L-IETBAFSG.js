import {
  __name,
  require_node_module,
  require_node_path,
  require_node_url
} from "./chunk-UW4EVAE5.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __privateWrapper,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/storybook/dist/_node-chunks/p-limit-IJ5D4B4L.js
var import_node_url = __toESM(require_node_url(), 1);
var import_node_path = __toESM(require_node_path(), 1);
var import_node_module = __toESM(require_node_module(), 1);
var __filename = import_node_url.default.fileURLToPath(import.meta.url);
var __dirname = import_node_path.default.dirname(__filename);
var require2 = import_node_module.default.createRequire(import.meta.url);
var _a;
var Node = (_a = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
}, __name(_a, "Node"), _a);
var _head, _tail, _size, _a2;
var Queue = (_a2 = class {
  constructor() {
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _size);
    this.clear();
  }
  enqueue(value) {
    const node = new Node(value);
    if (__privateGet(this, _head)) {
      __privateGet(this, _tail).next = node;
      __privateSet(this, _tail, node);
    } else {
      __privateSet(this, _head, node);
      __privateSet(this, _tail, node);
    }
    __privateWrapper(this, _size)._++;
  }
  dequeue() {
    const current = __privateGet(this, _head);
    if (!current) {
      return;
    }
    __privateSet(this, _head, __privateGet(this, _head).next);
    __privateWrapper(this, _size)._--;
    if (!__privateGet(this, _head)) {
      __privateSet(this, _tail, void 0);
    }
    return current.value;
  }
  peek() {
    if (!__privateGet(this, _head)) {
      return;
    }
    return __privateGet(this, _head).value;
  }
  clear() {
    __privateSet(this, _head, void 0);
    __privateSet(this, _tail, void 0);
    __privateSet(this, _size, 0);
  }
  get size() {
    return __privateGet(this, _size);
  }
  *[Symbol.iterator]() {
    let current = __privateGet(this, _head);
    while (current) {
      yield current.value;
      current = current.next;
    }
  }
  *drain() {
    while (__privateGet(this, _head)) {
      yield this.dequeue();
    }
  }
}, _head = new WeakMap(), _tail = new WeakMap(), _size = new WeakMap(), __name(_a2, "Queue"), _a2);
function pLimit(concurrency) {
  validateConcurrency(concurrency);
  const queue = new Queue();
  let activeCount = 0;
  const resumeNext = __name(() => {
    if (activeCount < concurrency && queue.size > 0) {
      queue.dequeue()();
      activeCount++;
    }
  }, "resumeNext");
  const next = __name(() => {
    activeCount--;
    resumeNext();
  }, "next");
  const run = __name(async (function_, resolve, arguments_) => {
    const result = (async () => function_(...arguments_))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  }, "run");
  const enqueue = __name((function_, resolve, arguments_) => {
    new Promise((internalResolve) => {
      queue.enqueue(internalResolve);
    }).then(
      run.bind(void 0, function_, resolve, arguments_)
    );
    (async () => {
      await Promise.resolve();
      if (activeCount < concurrency) {
        resumeNext();
      }
    })();
  }, "enqueue");
  const generator = __name((function_, ...arguments_) => new Promise((resolve) => {
    enqueue(function_, resolve, arguments_);
  }), "generator");
  Object.defineProperties(generator, {
    activeCount: {
      get: __name(() => activeCount, "get")
    },
    pendingCount: {
      get: __name(() => queue.size, "get")
    },
    clearQueue: {
      value() {
        queue.clear();
      }
    },
    concurrency: {
      get: __name(() => concurrency, "get"),
      set(newConcurrency) {
        validateConcurrency(newConcurrency);
        concurrency = newConcurrency;
        queueMicrotask(() => {
          while (activeCount < concurrency && queue.size > 0) {
            resumeNext();
          }
        });
      }
    }
  });
  return generator;
}
__name(pLimit, "pLimit");
function limitFunction(function_, option) {
  const { concurrency } = option;
  const limit = pLimit(concurrency);
  return (...arguments_) => limit(() => function_(...arguments_));
}
__name(limitFunction, "limitFunction");
function validateConcurrency(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  }
}
__name(validateConcurrency, "validateConcurrency");
export {
  pLimit as default,
  limitFunction
};
//# sourceMappingURL=p-limit-IJ5D4B4L-IETBAFSG.js.map
